class Tree {
    constructor(object = undefined) {
        this.rootNode = null;

        if (object) {
            this.rootNode = new Node(object);
        }
    }


    get(path) {
        return this.rootNode.get(path);
    }

    set(path, value) {
        this.rootNode.set(path, value);
    }

    add(callback, object) {
        const type = typeof callback;

        if (type === 'string' && callback === 'root') {
            this.rootNode = new Node(object);
            return this;
        } else if (type === 'function') {
            const target = searchNode(this, null, callback);

            if (target && target.add(object)) {
                return this;
            } else {
                console.log('Warning', object);
            }
        }
    }

    contains(criteria) {
        return searchNode(this, null, criteria);
    }

    remove(criteria) {
        const targetNode = this.contains(criteria);

        if (targetNode) {
            return !!targetNode.parent.remove(criteria);
        }

        return false;
    }

    move(search, destination) {
        const targetNode = this.contains(search);

        if (targetNode && this.remove(search)) {
            const destinationNode = this.contains(destination);
            return !!destinationNode.add(targetNode);
        }

        return false;
    }

    traversal(criteria, callback) {
        traversalTree(this, null, criteria, callback);
    }

    sort(compare) {
        this.traversal(null, currentNode => {
            currentNode.sort(compare);
        });
    }

    toJson(options = {}) {
        const optionsDefault = {
            key_children: 'children',
            empty_children: true
        };
        options = Object.assign(optionsDefault, options);
        const result = serializeTree(this, null, [], options);

        if (!options.empty_children) {
            removeEmptyChildren(result, null, options);
        }

        if (result && result.length > 0) {
            return result[0];
        } else {
            return [];
        }
    }

}

const defaultOptions = {
    key_id: 'id',
    key_parent: 'parent',
    key_child: 'child',
    key_last: null,
    uuid: false,
    empty_children: false
}

function sortBy(collection, propertyA, propertyB) {
    return collection.sort(function(a, b) {
        if (a[propertyB] < b[propertyB]) {
            if (a[propertyA] > b[propertyA]) {
                return 1;
            }

            return -1;
        } else {
            if (a[propertyA] < b[propertyA]) {
                return -1;
            }

            return 1;
        }
    });
}

